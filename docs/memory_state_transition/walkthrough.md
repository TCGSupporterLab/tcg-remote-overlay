# メモリ優先の状態管理への移行完了

## 実施した変更内容

### 1. App.tsx: ライブキャッシュ (`liveWidgetStatesRef`) の導入と網羅
- すべてのウィジェットの最新状態をメモリ上に保持する仕組みを構築しました。
- **追加修正**: グループ操作だけでなく、ウィジェット単体の操作時にも常にキャッシュを更新するようにし、データソースの不一致を解消しました。
- `handleManipulationStart` で `localStorage` を一切読まず、このキャッシュからスナップショットを取得するように変更しました。

### 2. OverlayWidget.tsx: 内部ステートの自動同期
- **重要**: グループ移動によって計算された位置情報を Props (`externalState`) で受け取った際、自身が操作中でなければ内部の `state` に書き戻すようにしました。
- これにより、「グループで動かした直後に単体で動かす」という操作の切り替え時に、古い位置情報が呼び出されることによる「座標ジャンプ」を完全に防止しました。

### 3. GroupBoundingBox.tsx: localStorage 依存の完全排除
- 自ら `localStorage` を見に行く `readAnchorState` 関数を廃止しました。
- `App.tsx` から供給される最新のキャッシュデータ (`externalAnchorState`) のみを計算の起点とするように整理しました。

### 4. 同期ロジックの安定化と最適化
- 各ウィンドウが通信時に `senderId` を付与し、自身の送信したメッセージを二重処理しないように徹底しました。
- 不要な再レンダリングや無限ループを防ぐため、ステート更新時に微細な変化を無視する閾値判定 (`threshold`) を導入しました。これにより `Maximum update depth exceeded` エラーも解消されています。

## 検証結果

### 動作確認
- 複数オブジェクトを移動した直後の回転操作、およびその後の個別移動において、座標が不連続に飛ぶ現象が解消されたことを確認しました。
- 単体操作とグループ操作を交互に行っても、常に正しい位置から操作が開始されます。

### 冗長なアクセスの削減
- `localStorage` へのリアルタイムな読み込みを廃止し、メモリ上での高速な計算に切り替えたことで、UI のレスポンスが向上しました。
